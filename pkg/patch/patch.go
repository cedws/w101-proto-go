// Code generated by w101-client-go. DO NOT EDIT.
package patch

import (
	"bytes"
	"encoding/binary"
	"github.com/cedws/w101-client-go/codegen"
	"github.com/cedws/w101-client-go/proto"
)

type service interface {
	LatestFileList(LatestFileList)
	LatestFileListV2(LatestFileListV2)
	NextVersion(NextVersion)
}

func (Service) LatestFileList(LatestFileList)     {}
func (Service) LatestFileListV2(LatestFileListV2) {}
func (Service) NextVersion(NextVersion)           {}

func RegisterService(r *proto.MessageRouter, s service) {
	proto.RegisterMessageHandler(r, 8, 1, s.LatestFileList)
	proto.RegisterMessageHandler(r, 8, 2, s.LatestFileListV2)
	proto.RegisterMessageHandler(r, 8, 3, s.NextVersion)
}

func NewClient(c *proto.Client) Client {
	return Client{c}
}

func (c Client) LatestFileList(m *LatestFileList) error {
	return c.c.WriteMessage(8, 1, m)
}

func (c Client) LatestFileListV2(m *LatestFileListV2) error {
	return c.c.WriteMessage(8, 2, m)
}

func (c Client) NextVersion(m *NextVersion) error {
	return c.c.WriteMessage(8, 3, m)
}

type Service struct {
	service
}

type Client struct {
	c *proto.Client
}
type LatestFileList struct {
	URLSuffix     string
	URLPrefix     string
	ListFileURL   string
	ListFileName  string
	LatestVersion uint32
	ListFileType  uint32
	ListFileTime  uint32
	ListFileSize  uint32
	ListFileCRC   uint32
}

func (s *LatestFileList) Marshal() []byte {
	b := bytes.NewBuffer(make([]byte, 0, 28+len(s.ListFileName)+len(s.ListFileURL)+len(s.URLPrefix)+len(s.URLSuffix)))
	binary.Write(b, binary.LittleEndian, s.ListFileName)
	binary.Write(b, binary.LittleEndian, s.ListFileURL)
	binary.Write(b, binary.LittleEndian, s.URLPrefix)
	binary.Write(b, binary.LittleEndian, s.URLSuffix)
	return b.Bytes()
}

func (s *LatestFileList) Unmarshal(data []byte) error {
	b := bytes.NewReader(data)
	var err error
	if err = binary.Read(b, binary.LittleEndian, &s.LatestVersion); err != nil {
		return err
	}
	if s.ListFileName, err = codegen.ReadString(b); err != nil {
		return err
	}
	if err = binary.Read(b, binary.LittleEndian, &s.ListFileType); err != nil {
		return err
	}
	if err = binary.Read(b, binary.LittleEndian, &s.ListFileTime); err != nil {
		return err
	}
	if err = binary.Read(b, binary.LittleEndian, &s.ListFileSize); err != nil {
		return err
	}
	if err = binary.Read(b, binary.LittleEndian, &s.ListFileCRC); err != nil {
		return err
	}
	if s.ListFileURL, err = codegen.ReadString(b); err != nil {
		return err
	}
	if s.URLPrefix, err = codegen.ReadString(b); err != nil {
		return err
	}
	if s.URLSuffix, err = codegen.ReadString(b); err != nil {
		return err
	}
	return nil
}

type LatestFileListV2 struct {
	Locale        string
	URLSuffix     string
	URLPrefix     string
	ListFileURL   string
	ListFileName  string
	LatestVersion uint32
	ListFileType  uint32
	ListFileTime  uint32
	ListFileSize  uint32
	ListFileCRC   uint32
}

func (s *LatestFileListV2) Marshal() []byte {
	b := bytes.NewBuffer(make([]byte, 0, 30+len(s.ListFileName)+len(s.ListFileURL)+len(s.URLPrefix)+len(s.URLSuffix)+len(s.Locale)))
	binary.Write(b, binary.LittleEndian, s.ListFileName)
	binary.Write(b, binary.LittleEndian, s.ListFileURL)
	binary.Write(b, binary.LittleEndian, s.URLPrefix)
	binary.Write(b, binary.LittleEndian, s.URLSuffix)
	binary.Write(b, binary.LittleEndian, s.Locale)
	return b.Bytes()
}

func (s *LatestFileListV2) Unmarshal(data []byte) error {
	b := bytes.NewReader(data)
	var err error
	if err = binary.Read(b, binary.LittleEndian, &s.LatestVersion); err != nil {
		return err
	}
	if s.ListFileName, err = codegen.ReadString(b); err != nil {
		return err
	}
	if err = binary.Read(b, binary.LittleEndian, &s.ListFileType); err != nil {
		return err
	}
	if err = binary.Read(b, binary.LittleEndian, &s.ListFileTime); err != nil {
		return err
	}
	if err = binary.Read(b, binary.LittleEndian, &s.ListFileSize); err != nil {
		return err
	}
	if err = binary.Read(b, binary.LittleEndian, &s.ListFileCRC); err != nil {
		return err
	}
	if s.ListFileURL, err = codegen.ReadString(b); err != nil {
		return err
	}
	if s.URLPrefix, err = codegen.ReadString(b); err != nil {
		return err
	}
	if s.URLSuffix, err = codegen.ReadString(b); err != nil {
		return err
	}
	if s.Locale, err = codegen.ReadString(b); err != nil {
		return err
	}
	return nil
}

type NextVersion struct {
	FileName  string
	URLPrefix string
	PkgName   string
	Version   int32
	FileType  int32
}

func (s *NextVersion) Marshal() []byte {
	b := bytes.NewBuffer(make([]byte, 0, 14+len(s.PkgName)+len(s.URLPrefix)+len(s.FileName)))
	binary.Write(b, binary.LittleEndian, s.PkgName)
	binary.Write(b, binary.LittleEndian, s.URLPrefix)
	binary.Write(b, binary.LittleEndian, s.FileName)
	return b.Bytes()
}

func (s *NextVersion) Unmarshal(data []byte) error {
	b := bytes.NewReader(data)
	var err error
	if s.PkgName, err = codegen.ReadString(b); err != nil {
		return err
	}
	if err = binary.Read(b, binary.LittleEndian, &s.Version); err != nil {
		return err
	}
	if s.URLPrefix, err = codegen.ReadString(b); err != nil {
		return err
	}
	if s.FileName, err = codegen.ReadString(b); err != nil {
		return err
	}
	if err = binary.Read(b, binary.LittleEndian, &s.FileType); err != nil {
		return err
	}
	return nil
}
